<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KL Divergence: Forward vs Reverse</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d4ff, #7b68ee, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 1.1em;
            color: #a0a0c0;
            margin-bottom: 30px;
            text-align: center;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: #b0b0d0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.5);
        }

        .value-display {
            font-size: 0.85em;
            color: #00d4ff;
            font-weight: bold;
        }

        button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        canvas {
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            max-width: 100%;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-line {
            width: 30px;
            height: 3px;
            border-radius: 2px;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.85em;
            color: #808090;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #00d4ff;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 25px;
        }

        .mode-btn {
            padding: 8px 20px;
            background: transparent;
            color: #a0a0c0;
            border: none;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
    </style>
</head>
<body>
    <h1>KL Divergence Optimization</h1>
    <div class="subtitle">Visualizing Forward KL(p||q) vs Reverse KL(q||p) Minimization</div>
    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label>Mode Separation</label>
                <input type="range" id="separation" min="0" max="15" step="0.1" value="5">
                <span class="value-display" id="separationValue">5.0</span>
            </div>
            
            <div class="control-group">
                <label>Animation Speed</label>
                <input type="range" id="speed" min="0.25" max="3" step="0.25" value="1">
                <span class="value-display" id="speedValue">1.0x</span>
            </div>
            
            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="both">Both KL</button>
                <button class="mode-btn" data-mode="forward">Forward Only</button>
                <button class="mode-btn" data-mode="reverse">Reverse Only</button>
            </div>
            
            <button id="animateBtn">Start Animation</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-line" style="background: #00d4ff;"></div>
                <span>Target p(x) - Bimodal</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #ff6b6b; border: 2px dashed #ff6b6b; background: none;"></div>
                <span>Forward KL: q<sub>θ</sub><sup>*</sup> = arg min<sub>θ</sub> D<sub>KL</sub>(p || q<sub>θ</sub>)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #7b68ee; border: 2px dotted #7b68ee; background: none;"></div>
                <span>Reverse KL: q<sub>θ</sub><sup>*</sup> = arg min<sub>θ</sub> D<sub>KL</sub>(q<sub>θ</sub> || p)</span>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="info-item">
                <div class="info-label">D<sub>KL</sub>(p || q<sub>θ</sub>)</div>
                <div class="info-value" id="forwardKL">0.000</div>
            </div>
            <div class="info-item">
                <div class="info-label">D<sub>KL</sub>(q<sub>θ</sub> || p)</div>
                <div class="info-value" id="reverseKL">0.000</div>
            </div>
            <div class="info-item">
                <div class="info-label">Optimization Step</div>
                <div class="info-value" id="step">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Convergence</div>
                <div class="info-value" id="convergence">0%</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = Math.min(1100, window.innerWidth - 100);
            canvas.height = 400;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Parameters
        let separation = 5;
        let animationSpeed = 1;
        let isAnimating = false;
        let animationFrame = null;
        let currentStep = 0;
        let displayMode = 'both';
        
        // Optimization parameters
        let forwardQ = { mean: 2.5, std: 2 };
        let reverseQ = { mean: 0, std: 1 };
        let targetForwardQ = { mean: 2.5, std: 3 };
        let targetReverseQ = { mean: 0, std: 1 };
        
        // Gaussian functions
        function gaussian(x, mean, std) {
            const coefficient = 1 / (std * Math.sqrt(2 * Math.PI));
            const exponent = -0.5 * Math.pow((x - mean) / std, 2);
            return coefficient * Math.exp(exponent);
        }
        
        function bimodalGaussian(x, separation) {
            return 0.5 * gaussian(x, 0, 1) + 0.5 * gaussian(x, separation, 1);
        }
        
        // KL divergence approximations
        function computeKL(p, q, xs) {
            let kl = 0;
            const dx = xs[1] - xs[0];
            for (let i = 0; i < xs.length; i++) {
                const px = p(xs[i]);
                const qx = q(xs[i]);
                if (px > 1e-10 && qx > 1e-10) {
                    kl += px * Math.log(px / qx) * dx;
                }
            }
            return kl;
        }
        
        // Grid search for optimal parameters
        function optimizeForwardKL(separation) {
            // For forward KL, we minimize KL(p||q) = ∫ p(x) log(p(x)/q(x)) dx
            // This should result in q matching the mean and variance of p
            
            // The bimodal distribution has:
            // Mean = (0 + separation) / 2 = separation / 2
            // For variance, we need to compute it properly
            
            // When minimizing KL(p||q), the optimal Gaussian q has:
            // - mean equal to the mean of p
            // - variance equal to the variance of p
            
            const pMean = separation / 2;
            
            // Variance of bimodal: E[X^2] - (E[X])^2
            // Each component has variance 1 and means at 0 and separation
            // E[X] = separation/2
            // E[X^2] = 0.5 * (0^2 + 1) + 0.5 * (separation^2 + 1) = 0.5 * (1 + separation^2 + 1) = 1 + separation^2/2
            // Var[X] = E[X^2] - (E[X])^2 = 1 + separation^2/2 - separation^2/4 = 1 + separation^2/4
            
            const pVariance = 1 + (separation * separation) / 4;
            const pStd = Math.sqrt(pVariance);
            
            // For verification, also compute the KL
            const xs = [];
            for (let x = -8; x <= separation + 8; x += 0.05) {
                xs.push(x);
            }
            
            const p = x => bimodalGaussian(x, separation);
            const q = x => gaussian(x, pMean, pStd);
            const kl = computeKL(p, q, xs);
            
            return { mean: pMean, std: pStd, kl: kl };
        }
        
        function optimizeReverseKL(separation) {
            const xs = [];
            for (let x = -8; x <= separation + 8; x += 0.05) {
                xs.push(x);
            }
            
            let bestMean = 0;
            let bestStd = 1;
            let minKL = Infinity;
            
            // For reverse KL, search more broadly as it might pick either mode
            for (let mean = -1; mean <= separation + 1; mean += 0.1) {
                for (let std = 0.3; std <= 2; std += 0.1) {
                    const p = x => bimodalGaussian(x, separation);
                    const q = x => gaussian(x, mean, std);
                    const kl = computeKL(q, p, xs);
                    
                    if (kl < minKL) {
                        minKL = kl;
                        bestMean = mean;
                        bestStd = std;
                    }
                }
            }
            
            // When modes are well-separated, reverse KL should pick one mode
            // Check both modes explicitly
            if (separation > 3) {
                // Check left mode
                for (let std = 0.5; std <= 1.5; std += 0.1) {
                    const q = x => gaussian(x, 0, std);
                    const p = x => bimodalGaussian(x, separation);
                    const kl = computeKL(q, p, xs);
                    
                    if (kl < minKL) {
                        minKL = kl;
                        bestMean = 0;
                        bestStd = std;
                    }
                }
                
                // Check right mode
                for (let std = 0.5; std <= 1.5; std += 0.1) {
                    const q = x => gaussian(x, separation, std);
                    const p = x => bimodalGaussian(x, separation);
                    const kl = computeKL(q, p, xs);
                    
                    if (kl < minKL) {
                        minKL = kl;
                        bestMean = separation;
                        bestStd = std;
                    }
                }
            }
            
            return { mean: bestMean, std: bestStd, kl: minKL };
        }
        
        // Drawing functions
        function drawDistribution(distribution, color, style = 'solid') {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            if (style === 'dashed') {
                ctx.setLineDash([10, 5]);
            } else if (style === 'dotted') {
                ctx.setLineDash([3, 3]);
            } else {
                ctx.setLineDash([]);
            }
            
            ctx.beginPath();
            
            const xMin = -8;
            const xMax = separation + 8;
            const steps = 500;
            
            for (let i = 0; i <= steps; i++) {
                const x = xMin + (xMax - xMin) * i / steps;
                const y = distribution(x);
                
                const px = padding + (x - xMin) / (xMax - xMin) * (width - 2 * padding);
                const py = height - padding - y * (height - 2 * padding) * 2;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawAxes() {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawAxes();
            
            // Draw target distribution
            drawDistribution(x => bimodalGaussian(x, separation), '#00d4ff', 'solid');
            
            // Draw approximations based on mode
            if (displayMode === 'both' || displayMode === 'forward') {
                drawDistribution(x => gaussian(x, forwardQ.mean, forwardQ.std), '#ff6b6b', 'dashed');
            }
            
            if (displayMode === 'both' || displayMode === 'reverse') {
                drawDistribution(x => gaussian(x, reverseQ.mean, reverseQ.std), '#7b68ee', 'dotted');
            }
            
            // Update info panel
            const xs = [];
            for (let x = -8; x <= separation + 8; x += 0.1) {
                xs.push(x);
            }
            
            const p = x => bimodalGaussian(x, separation);
            const qForward = x => gaussian(x, forwardQ.mean, forwardQ.std);
            const qReverse = x => gaussian(x, reverseQ.mean, reverseQ.std);
            
            const forwardKLValue = computeKL(p, qForward, xs);
            const reverseKLValue = computeKL(qReverse, p, xs);
            
            document.getElementById('forwardKL').textContent = forwardKLValue.toFixed(3);
            document.getElementById('reverseKL').textContent = reverseKLValue.toFixed(3);
        }
        
        function animate() {
            if (!isAnimating) return;
            
            currentStep++;
            const maxSteps = 600;  // Doubled to 600 for much longer animation
            
            if (currentStep <= maxSteps) {
                const t = currentStep / maxSteps;
                
                // Use a smoother easing function (ease-in-out cubic)
                const eased = t < 0.5 
                    ? 4 * t * t * t 
                    : 1 - Math.pow(-2 * t + 2, 3) / 2;
                
                // Even slower interpolation rate for smooth long animation
                const lerpRate = 0.008 * animationSpeed * (0.3 + 0.7 * eased);  // Reduced further for smoothness
                
                forwardQ.mean = forwardQ.mean + (targetForwardQ.mean - forwardQ.mean) * lerpRate;
                forwardQ.std = forwardQ.std + (targetForwardQ.std - forwardQ.std) * lerpRate;
                
                reverseQ.mean = reverseQ.mean + (targetReverseQ.mean - reverseQ.mean) * lerpRate;
                reverseQ.std = reverseQ.std + (targetReverseQ.std - reverseQ.std) * lerpRate;
                
                document.getElementById('step').textContent = currentStep;
                document.getElementById('convergence').textContent = Math.round(t * 100) + '%';
                
                draw();
                animationFrame = requestAnimationFrame(animate);
            } else {
                stopAnimation();
            }
        }
        
        function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            currentStep = 0;
            
            // Reset starting positions
            forwardQ = { mean: separation / 2, std: 1 };
            reverseQ = { mean: separation / 2, std: 1 };
            
            // Calculate target positions
            const forwardOptimal = optimizeForwardKL(separation);
            const reverseOptimal = optimizeReverseKL(separation);
            
            targetForwardQ = forwardOptimal;
            targetReverseQ = reverseOptimal;
            
            document.getElementById('animateBtn').textContent = 'Stop Animation';
            animate();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            document.getElementById('animateBtn').textContent = 'Start Animation';
        }
        
        // Event listeners
        document.getElementById('separation').addEventListener('input', (e) => {
            separation = parseFloat(e.target.value);
            document.getElementById('separationValue').textContent = separation.toFixed(1);
            
            // Recalculate optimal positions
            const forwardOptimal = optimizeForwardKL(separation);
            const reverseOptimal = optimizeReverseKL(separation);
            
            if (!isAnimating) {
                forwardQ = forwardOptimal;
                reverseQ = reverseOptimal;
                targetForwardQ = forwardOptimal;
                targetReverseQ = reverseOptimal;
            }
            
            draw();
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });
        
        document.getElementById('animateBtn').addEventListener('click', () => {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        });
        
        // Mode toggle buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                displayMode = btn.dataset.mode;
                draw();
            });
        });
        
        // Initial setup
        const forwardOptimal = optimizeForwardKL(separation);
        const reverseOptimal = optimizeReverseKL(separation);
        forwardQ = forwardOptimal;
        reverseQ = reverseOptimal;
        targetForwardQ = forwardOptimal;
        targetReverseQ = reverseOptimal;
        
        draw();
    </script>
</body>
</html>